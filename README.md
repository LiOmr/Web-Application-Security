# Web Application Security

```markdown
# HTTP Proxy Server & Vulnerability Scanner

Реализация HTTP прокси сервера и простого сканера уязвимостей на его основе (часть функционала Burp Suite без GUI).

Проект реализуется с использованием Docker (либо docker-compose с несколькими контейнерами), где:
- Прокси сервер слушает на порту **8080**
- Веб-API доступно на порту **8000**

---

## Функциональные требования

### 1. Проксирование HTTP запросов (20 баллов)

Проксирование HTTP запросов должно работать корректно. Пример использования:

- Запуск:
  ```bash
  curl -x http://127.0.0.1:8080 http://mail.ru
  ```
- Ожидаемый ответ:
  ```html
  <html>
  <head><title>301 Moved Permanently</title></head>
  <body bgcolor="white">
  <center><h1>301 Moved Permanently</h1></center>
  <hr><center>nginx/1.14.1</center>
  </body>
  </html>
  ```

#### Детали реализации:
- При получении запроса вида:
  ```
  GET http://mail.ru/ HTTP/1.1
  Host: mail.ru
  User-Agent: curl/7.64.1
  Accept: */*
  Proxy-Connection: Keep-Alive
  ```
- Необходимо:
  - Считать хост и порт из первой строки (например, `mail.ru` и порт `80`)
  - Заменить путь на относительный (например, `/`)
  - Удалить заголовок `Proxy-Connection`
- Итоговый запрос к целевому серверу должен иметь вид:
  ```
  GET / HTTP/1.1
  Host: mail.ru
  User-Agent: curl/7.64.1
  Accept: */*
  ```
- Все данные, полученные в ответ, должны быть корректно перенаправлены обратно клиенту.

Убедитесь, что:
- Проксируются все типы запросов (GET, POST, HEAD, OPTIONS и т.д.)
- Пересылаются все заголовки
- Корректно обрабатываются все коды ответов (200, 302, 404 и т.д.)

---

### 2. Проксирование HTTPS запросов (20 баллов)

Проксирование HTTPS запросов должно работать корректно. Пример использования:

- Запуск:
  ```bash
  curl -x http://127.0.0.1:8080 https://mail.ru
  ```
- На порт 8080 поступает запрос вида:
  ```
  CONNECT mail.ru:443 HTTP/1.1
  Host: mail.ru:443
  User-Agent: curl/7.64.1
  Proxy-Connection: Keep-Alive
  ```
  
#### Детали реализации:
- Считайте хост (`mail.ru`) и порт (`443`) из первой строки.
- Сразу верните ответ:
  ```
  HTTP/1.0 200 Connection established
  ```
  (При этом сокет не закрывается и используется для последующего защищённого соединения.)
- После установления защищённого соединения:
  - Сгенерируйте и подпишите сертификат для запрашиваемого хоста (например, `mail.ru`).  
    Примеры команд для генерации корневого сертификата и сертификата для хоста:
    - [gen_ca.sh](https://github.com/john-pentest/fproxy/blob/master/gen_ca.sh)
    - [gen_cert.sh](https://github.com/john-pentest/fproxy/blob/master/gen_cert.sh)
  - Установите защищённое соединение с целевым сервером (`mail.ru:443`), передавайте данные от клиента и возвращайте полученный ответ.

Проверьте, что возможно:
- Зайти на сайт (например, mail.ru)
- Авторизоваться и получить список писем

---

## API веб-интерфейс (порт 8000)

Обеспечьте работу следующих эндпоинтов:

- **GET `/requests`** – Получение списка всех проксированных запросов
- **GET `/requests/{id}`** – Получение подробной информации по конкретному запросу
- **POST `/repeat/{id}`** – Повторная отправка ранее проксированного запроса
- **POST `/scan/{id}`** – Запуск сканирования уязвимостей для данного запроса

---

## Сборка и запуск (Docker)

Проект необходимо упаковать в Docker контейнер или организовать через `docker-compose` (если используется несколько контейнеров).

### Пример `Dockerfile`
```dockerfile
FROM <базовый-образ>
WORKDIR /app
COPY . .
RUN <команда сборки, например: go build -o proxy . или pip install -r requirements.txt>
EXPOSE 8080 8000
CMD ["<команда для запуска приложения>"]
```

### Пример `docker-compose.yml`
```yaml
version: "3"
services:
  proxy:
    build: .
    ports:
      - "8080:8080"
  api:
    build: .
    ports:
      - "8000:8000"
```
*При необходимости адаптируйте конфигурацию под особенности реализации.*

---

## Дополнительные ссылки

- [Пример реализации fproxy (john-pentest)](https://github.com/john-pentest/fproxy)
- [Пример реализации MITM на Go (kr)](https://github.com/kr/mitm/blob/master/mitm.go)
